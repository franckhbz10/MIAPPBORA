-- Nuevo esquema para lexicón enriquecido y colección unificada de embeddings
-- Mantiene VECTOR(384) para all-MiniLM-L6-v2

CREATE EXTENSION IF NOT EXISTS vector;

-- 1) Tabla de lemas
CREATE TABLE IF NOT EXISTS lexicon_lemmas (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  lemma TEXT NOT NULL,
  gloss_es TEXT NOT NULL,
  pos TEXT,
  pos_full TEXT,
  page INT,
  variants JSONB,
  synonyms JSONB,
  raw TEXT,
  source TEXT DEFAULT 'salida.json',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (lemma, source)
);

-- 2) Tabla de subentradas
CREATE TABLE IF NOT EXISTS lexicon_subentries (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  lemma_id BIGINT NOT NULL REFERENCES lexicon_lemmas(id) ON DELETE CASCADE,
  sublemma TEXT,
  gloss_es TEXT NOT NULL,
  pos TEXT,
  pos_full TEXT,
  page INT,
  variants JSONB,
  synonyms JSONB,
  raw TEXT,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- 3) Tabla de ejemplos (parejas Bora↔ES)
CREATE TABLE IF NOT EXISTS lexicon_examples (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  lemma_id BIGINT NOT NULL REFERENCES lexicon_lemmas(id) ON DELETE CASCADE,
  subentry_id BIGINT REFERENCES lexicon_subentries(id) ON DELETE SET NULL,
  bora_text TEXT NOT NULL,
  spanish_text TEXT NOT NULL,
  category TEXT,
  page INT,
  source TEXT DEFAULT 'salida.json',
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  UNIQUE (lemma_id, bora_text, spanish_text, source)
);

-- 4) Colección unificada de documentos vectoriales
CREATE TABLE IF NOT EXISTS bora_docs (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  kind TEXT NOT NULL CHECK (kind IN ('lemma','subentry','example')),
  parent_lemma_id BIGINT NOT NULL REFERENCES lexicon_lemmas(id) ON DELETE CASCADE,
  subentry_id BIGINT REFERENCES lexicon_subentries(id) ON DELETE CASCADE,
  example_id BIGINT REFERENCES lexicon_examples(id) ON DELETE CASCADE,
  content TEXT NOT NULL,
  embedding VECTOR(384) NOT NULL,
  metadata JSONB,
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW()
);

-- Índices para performance
CREATE INDEX IF NOT EXISTS bora_docs_embedding_hnsw_idx
ON bora_docs USING hnsw (embedding vector_cosine_ops);

CREATE INDEX IF NOT EXISTS bora_docs_kind_parent_idx
ON bora_docs (kind, parent_lemma_id);

-- Unicidad lógica por combinación incluyendo NULL tratados como -1 (vía índice único por expresión)
CREATE UNIQUE INDEX IF NOT EXISTS bora_docs_unique_idx
ON bora_docs (
  kind,
  parent_lemma_id,
  COALESCE(subentry_id, -1),
  COALESCE(example_id, -1)
);

-- 5) RPC de búsqueda unificada
CREATE OR REPLACE FUNCTION match_bora_docs (
  query_embedding VECTOR(384),
  match_threshold FLOAT DEFAULT 0.5,
  match_count INT DEFAULT 10,
  kind_filter TEXT[] DEFAULT NULL,
  pos_filter TEXT DEFAULT NULL
)
RETURNS TABLE (
  id BIGINT,
  kind TEXT,
  parent_lemma_id BIGINT,
  subentry_id BIGINT,
  example_id BIGINT,
  lemma TEXT,
  pos_full TEXT,
  bora_text TEXT,
  spanish_text TEXT,
  gloss_es TEXT,
  similarity FLOAT
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public, pg_temp
AS $$
BEGIN
  RETURN QUERY
  SELECT
    d.id,
    d.kind,
    d.parent_lemma_id,
    d.subentry_id,
    d.example_id,
    l.lemma,
    l.pos_full,
    e.bora_text,
    e.spanish_text,
    COALESCE(s.gloss_es, l.gloss_es) AS gloss_es,
    1 - (d.embedding <=> query_embedding) AS similarity
  FROM bora_docs d
  JOIN lexicon_lemmas l ON d.parent_lemma_id = l.id
  LEFT JOIN lexicon_subentries s ON d.subentry_id = s.id
  LEFT JOIN lexicon_examples e ON d.example_id = e.id
  WHERE (kind_filter IS NULL OR d.kind = ANY(kind_filter))
    AND (pos_filter IS NULL OR l.pos_full = pos_filter)
    AND (1 - (d.embedding <=> query_embedding)) > match_threshold
  ORDER BY d.embedding <=> query_embedding
  LIMIT match_count;
END;
$$;

-- ===== Seguridad y permisos (RLS + Grants) =====

-- Habilitar RLS en todas las tablas
ALTER TABLE lexicon_lemmas ENABLE ROW LEVEL SECURITY;
ALTER TABLE lexicon_subentries ENABLE ROW LEVEL SECURITY;
ALTER TABLE lexicon_examples ENABLE ROW LEVEL SECURITY;
ALTER TABLE bora_docs ENABLE ROW LEVEL SECURITY;

-- Políticas de lectura pública (frontend vía backend) para usuarios anon/authenticated
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'lexicon_lemmas' AND policyname = 'lemmas_select_public'
  ) THEN
    CREATE POLICY lemmas_select_public ON lexicon_lemmas
      FOR SELECT TO anon, authenticated USING (true);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'lexicon_subentries' AND policyname = 'subentries_select_public'
  ) THEN
    CREATE POLICY subentries_select_public ON lexicon_subentries
      FOR SELECT TO anon, authenticated USING (true);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'lexicon_examples' AND policyname = 'examples_select_public'
  ) THEN
    CREATE POLICY examples_select_public ON lexicon_examples
      FOR SELECT TO anon, authenticated USING (true);
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'bora_docs' AND policyname = 'boradocs_select_public'
  ) THEN
    CREATE POLICY boradocs_select_public ON bora_docs
      FOR SELECT TO anon, authenticated USING (true);
  END IF;
END $$;

-- Políticas de escritura restringidas a service_role (ingesta server-side)
DO $$
BEGIN
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'lexicon_lemmas' AND policyname = 'lemmas_write_service'
  ) THEN
    CREATE POLICY lemmas_write_service ON lexicon_lemmas
      FOR ALL TO service_role
      USING (auth.role() = 'service_role')
      WITH CHECK (auth.role() = 'service_role');
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'lexicon_subentries' AND policyname = 'subentries_write_service'
  ) THEN
    CREATE POLICY subentries_write_service ON lexicon_subentries
      FOR ALL TO service_role
      USING (auth.role() = 'service_role')
      WITH CHECK (auth.role() = 'service_role');
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'lexicon_examples' AND policyname = 'examples_write_service'
  ) THEN
    CREATE POLICY examples_write_service ON lexicon_examples
      FOR ALL TO service_role
      USING (auth.role() = 'service_role')
      WITH CHECK (auth.role() = 'service_role');
  END IF;
  IF NOT EXISTS (
    SELECT 1 FROM pg_policies WHERE schemaname = 'public' AND tablename = 'bora_docs' AND policyname = 'boradocs_write_service'
  ) THEN
    CREATE POLICY boradocs_write_service ON bora_docs
      FOR ALL TO service_role
      USING (auth.role() = 'service_role')
      WITH CHECK (auth.role() = 'service_role');
  END IF;
END $$;

-- Grants explícitos (opcionales, PostgREST utilizará RLS + roles)
GRANT SELECT ON lexicon_lemmas TO anon, authenticated;
GRANT SELECT ON lexicon_subentries TO anon, authenticated;
GRANT SELECT ON lexicon_examples TO anon, authenticated;
GRANT SELECT ON bora_docs TO anon, authenticated;

-- Permitir ejecutar la función de búsqueda desde el backend (anon/authenticated)
GRANT EXECUTE ON FUNCTION match_bora_docs(vector(384), double precision, integer, text[], text) TO anon, authenticated, service_role;
